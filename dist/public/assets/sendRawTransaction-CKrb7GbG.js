const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/secp256k1-wTtarEZj.js","assets/index-CrMWBvJr.js","assets/index-BccsffLE.css"])))=>i.map(i=>d[i]);
import{ao as Q,b4 as oe,al as D,ar as U,b5 as ie,aG as j,av as ce,at as V,ax as ue,b6 as de,as as T,aE as fe,p as v,aV as le,aW as $,b7 as me,U as pe,aF as ye,q as Y,b8 as be,b9 as he,ba as ge,bb as we,bc as Pe,bd as Z,be as xe,bf as ee,aX as Fe,aC as ke,aL as Te,bg as Ge,aM as W}from"./index-CrMWBvJr.js";import{a as Be,c as w,b as te,ac as ve,f as Ee,e as Ie,j as _e,ap as Re,w as Ne}from"./watchBlockNumber-DIG02Q_w.js";function Ae(e){const t=Q(`0x${e.substring(4)}`).substring(26);return oe(`0x${t}`)}async function qe({hash:e,signature:t}){const s=D(e)?e:U(e),{secp256k1:a}=await ie(async()=>{const{secp256k1:o}=await import("./secp256k1-wTtarEZj.js").then(i=>i.a);return{secp256k1:o}},__vite__mapDeps([0,1,2]));return`0x${(()=>{if(typeof t=="object"&&"r"in t&&"s"in t){const{r:c,s:p,v:d,yParity:n}=t,f=Number(n??d),m=X(f);return new a.Signature(j(c),j(p)).addRecoveryBit(m)}const o=D(t)?t:U(t);if(ce(o)!==65)throw new Error("invalid signature length");const i=V(`0x${o.slice(130)}`),u=X(i);return a.Signature.fromCompact(o.substring(2,130)).addRecoveryBit(u)})().recoverPublicKey(s.substring(2)).toHex(!1)}`}function X(e){if(e===0||e===1)return e;if(e===27)return 0;if(e===28)return 1;throw new Error("Invalid yParityOrV value")}async function He({hash:e,signature:t}){return Ae(await qe({hash:e,signature:t}))}function Me(e){const{chainId:t,nonce:s,to:a}=e,r=e.contractAddress??e.address,l=Q(ue(["0x05",de([t?T(t):"0x",r,s?T(s):"0x"])]));return a==="bytes"?fe(l):l}async function Ce(e){const{authorization:t,signature:s}=e;return He({hash:Me(t),signature:s??t})}class $e extends v{constructor(t,{account:s,docsPath:a,chain:r,data:l,gas:o,gasPrice:i,maxFeePerGas:u,maxPriorityFeePerGas:c,nonce:p,to:d,value:n}){var m;const f=le({from:s==null?void 0:s.address,to:d,value:typeof n<"u"&&`${me(n)} ${((m=r==null?void 0:r.nativeCurrency)==null?void 0:m.symbol)||"ETH"}`,data:l,gas:o,gasPrice:typeof i<"u"&&`${$(i)} gwei`,maxFeePerGas:typeof u<"u"&&`${$(u)} gwei`,maxPriorityFeePerGas:typeof c<"u"&&`${$(c)} gwei`,nonce:p});super(t.shortMessage,{cause:t,docsPath:a,metaMessages:[...t.metaMessages?[...t.metaMessages," "]:[],"Estimate Gas Arguments:",f].filter(Boolean),name:"EstimateGasExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=t}}function Se(e,{docsPath:t,...s}){const a=(()=>{const r=Be(e,s);return r instanceof pe?e:r})();return new $e(a,{docsPath:t,...s})}class ze extends v{constructor(){super("`baseFeeMultiplier` must be greater than 1.",{name:"BaseFeeScalarError"})}}class O extends v{constructor(){super("Chain does not support EIP-1559 fees.",{name:"Eip1559FeesNotSupportedError"})}}class je extends v{constructor({maxPriorityFeePerGas:t}){super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${$(t)} gwei).`,{name:"MaxFeePerGasTooLowError"})}}class ae extends v{constructor({blockHash:t,blockNumber:s}){let a="Block";t&&(a=`Block at hash "${t}"`),s&&(a=`Block at number "${s}"`),super(`${a} could not be found.`,{name:"BlockNotFoundError"})}}async function q(e,{blockHash:t,blockNumber:s,blockTag:a=e.experimental_blockTag??"latest",includeTransactions:r}={}){var c,p,d;const l=r??!1,o=s!==void 0?T(s):void 0;let i=null;if(t?i=await e.request({method:"eth_getBlockByHash",params:[t,l]},{dedupe:!0}):i=await e.request({method:"eth_getBlockByNumber",params:[o||a,l]},{dedupe:!!o}),!i)throw new ae({blockHash:t,blockNumber:s});return(((d=(p=(c=e.chain)==null?void 0:c.formatters)==null?void 0:p.block)==null?void 0:d.format)||ye)(i)}async function re(e){const t=await e.request({method:"eth_gasPrice"});return BigInt(t)}async function Je(e,t){return se(e,t)}async function se(e,t){var l,o;const{block:s,chain:a=e.chain,request:r}=t||{};try{const i=((l=a==null?void 0:a.fees)==null?void 0:l.maxPriorityFeePerGas)??((o=a==null?void 0:a.fees)==null?void 0:o.defaultPriorityFee);if(typeof i=="function"){const c=s||await w(e,q,"getBlock")({}),p=await i({block:c,client:e,request:r});if(p===null)throw new Error;return p}if(typeof i<"u")return i;const u=await e.request({method:"eth_maxPriorityFeePerGas"});return j(u)}catch{const[i,u]=await Promise.all([s?Promise.resolve(s):w(e,q,"getBlock")({}),w(e,re,"getGasPrice")({})]);if(typeof i.baseFeePerGas!="bigint")throw new O;const c=u-i.baseFeePerGas;return c<0n?0n:c}}async function Qe(e,t){return L(e,t)}async function L(e,t){var n,f;const{block:s,chain:a=e.chain,request:r,type:l="eip1559"}=t||{},o=await(async()=>{var m,y;return typeof((m=a==null?void 0:a.fees)==null?void 0:m.baseFeeMultiplier)=="function"?a.fees.baseFeeMultiplier({block:s,client:e,request:r}):((y=a==null?void 0:a.fees)==null?void 0:y.baseFeeMultiplier)??1.2})();if(o<1)throw new ze;const u=10**(((n=o.toString().split(".")[1])==null?void 0:n.length)??0),c=m=>m*BigInt(Math.ceil(o*u))/BigInt(u),p=s||await w(e,q,"getBlock")({});if(typeof((f=a==null?void 0:a.fees)==null?void 0:f.estimateFeesPerGas)=="function"){const m=await a.fees.estimateFeesPerGas({block:s,client:e,multiply:c,request:r,type:l});if(m!==null)return m}if(l==="eip1559"){if(typeof p.baseFeePerGas!="bigint")throw new O;const m=typeof(r==null?void 0:r.maxPriorityFeePerGas)=="bigint"?r.maxPriorityFeePerGas:await se(e,{block:p,chain:a,request:r}),y=c(p.baseFeePerGas);return{maxFeePerGas:(r==null?void 0:r.maxFeePerGas)??y+m,maxPriorityFeePerGas:m}}return{gasPrice:(r==null?void 0:r.gasPrice)??c(await w(e,re,"getGasPrice")({}))}}async function Le(e,{address:t,blockTag:s="latest",blockNumber:a}){const r=await e.request({method:"eth_getTransactionCount",params:[t,typeof a=="bigint"?T(a):s]},{dedupe:!!a});return V(r)}async function Ve(e){const t=await e.request({method:"eth_chainId"},{dedupe:!0});return V(t)}const Oe=["blobVersionedHashes","chainId","fees","gas","nonce","type"],J=new Map;async function Ke(e,t){const{account:s=e.account,blobs:a,chain:r,gas:l,kzg:o,nonce:i,nonceManager:u,parameters:c=Oe,type:p}=t,d=s&&Y(s),n={...t,...d?{from:d==null?void 0:d.address}:{}};let f;async function m(){return f||(f=await w(e,q,"getBlock")({blockTag:"latest"}),f)}let y;async function P(){return y||(r?r.id:typeof t.chainId<"u"?t.chainId:(y=await w(e,Ve,"getChainId")({}),y))}if(c.includes("nonce")&&typeof i>"u"&&d)if(u){const b=await P();n.nonce=await u.consume({address:d.address,chainId:b,client:e})}else n.nonce=await w(e,Le,"getTransactionCount")({address:d.address,blockTag:"pending"});if((c.includes("blobVersionedHashes")||c.includes("sidecars"))&&a&&o){const b=be({blobs:a,kzg:o});if(c.includes("blobVersionedHashes")){const g=he({commitments:b,to:"hex"});n.blobVersionedHashes=g}if(c.includes("sidecars")){const g=ge({blobs:a,commitments:b,kzg:o}),F=we({blobs:a,commitments:b,proofs:g,to:"hex"});n.sidecars=F}}if(c.includes("chainId")&&(n.chainId=await P()),(c.includes("fees")||c.includes("type"))&&typeof p>"u")try{n.type=Pe(n)}catch{let b=J.get(e.uid);if(typeof b>"u"){const g=await m();b=typeof(g==null?void 0:g.baseFeePerGas)=="bigint",J.set(e.uid,b)}n.type=b?"eip1559":"legacy"}if(c.includes("fees"))if(n.type!=="legacy"&&n.type!=="eip2930"){if(typeof n.maxFeePerGas>"u"||typeof n.maxPriorityFeePerGas>"u"){const b=await m(),{maxFeePerGas:g,maxPriorityFeePerGas:F}=await L(e,{block:b,chain:r,request:n});if(typeof t.maxPriorityFeePerGas>"u"&&t.maxFeePerGas&&t.maxFeePerGas<F)throw new je({maxPriorityFeePerGas:F});n.maxPriorityFeePerGas=F,n.maxFeePerGas=g}}else{if(typeof t.maxFeePerGas<"u"||typeof t.maxPriorityFeePerGas<"u")throw new O;if(typeof t.gasPrice>"u"){const b=await m(),{gasPrice:g}=await L(e,{block:b,chain:r,request:n,type:"legacy"});n.gasPrice=g}}return c.includes("gas")&&typeof l>"u"&&(n.gas=await w(e,De,"estimateGas")({...n,account:d&&{address:d.address,type:"json-rpc"}})),te(n),delete n.parameters,n}async function De(e,t){var r,l,o;const{account:s=e.account}=t,a=s?Y(s):void 0;try{let C=function(S){const{block:A,request:E,rpcStateOverride:_}=S;return e.request({method:"eth_estimateGas",params:_?[E,A??e.experimental_blockTag??"latest",_]:A?[E,A]:[E]})};const{accessList:i,authorizationList:u,blobs:c,blobVersionedHashes:p,blockNumber:d,blockTag:n,data:f,gas:m,gasPrice:y,maxFeePerBlobGas:P,maxFeePerGas:b,maxPriorityFeePerGas:g,nonce:F,value:H,stateOverride:h,...R}=await Ke(e,{...t,parameters:(a==null?void 0:a.type)==="local"?void 0:["blobVersionedHashes"]}),G=(typeof d=="bigint"?T(d):void 0)||n,B=ve(h),N=await(async()=>{if(R.to)return R.to;if(u&&u.length>0)return await Ce({authorization:u[0]}).catch(()=>{throw new v("`to` is required. Could not infer from `authorizationList`")})})();te(t);const x=(o=(l=(r=e.chain)==null?void 0:r.formatters)==null?void 0:l.transactionRequest)==null?void 0:o.format,k=(x||Ee)({...Ie(R,{format:x}),from:a==null?void 0:a.address,accessList:i,authorizationList:u,blobs:c,blobVersionedHashes:p,data:f,gas:m,gasPrice:y,maxFeePerBlobGas:P,maxFeePerGas:b,maxPriorityFeePerGas:g,nonce:F,to:N,value:H});let K=BigInt(await C({block:G,request:k,rpcStateOverride:B}));if(u){const S=await _e(e,{address:k.from}),A=await Promise.all(u.map(async E=>{const{address:_}=E,ne=await C({block:G,request:{authorizationList:void 0,data:f,from:a==null?void 0:a.address,to:_,value:T(S)},rpcStateOverride:B}).catch(()=>100000n);return 2n*BigInt(ne)}));K+=A.reduce((E,_)=>E+_,0n)}return K}catch(i){throw Se(i,{...t,account:a,chain:e.chain})}}async function Ue(e,{blockHash:t,blockNumber:s,blockTag:a,hash:r,index:l}){var p,d,n;const o=a||"latest",i=s!==void 0?T(s):void 0;let u=null;if(r?u=await e.request({method:"eth_getTransactionByHash",params:[r]},{dedupe:!0}):t?u=await e.request({method:"eth_getTransactionByBlockHashAndIndex",params:[t,T(l)]},{dedupe:!0}):u=await e.request({method:"eth_getTransactionByBlockNumberAndIndex",params:[i||o,T(l)]},{dedupe:!!i}),!u)throw new Z({blockHash:t,blockNumber:s,blockTag:o,hash:r,index:l});return(((n=(d=(p=e.chain)==null?void 0:p.formatters)==null?void 0:d.transaction)==null?void 0:n.format)||xe)(u)}async function z(e,{hash:t}){var r,l,o;const s=await e.request({method:"eth_getTransactionReceipt",params:[t]},{dedupe:!0});if(!s)throw new ee({hash:t});return(((o=(l=(r=e.chain)==null?void 0:r.formatters)==null?void 0:l.transactionReceipt)==null?void 0:o.format)||Fe)(s)}async function Ye(e,t){const{checkReplacement:s=!0,confirmations:a=1,hash:r,onReplaced:l,retryCount:o=6,retryDelay:i=({count:h})=>~~(1<<h)*200,timeout:u=18e4}=t,c=ke(["waitForTransactionReceipt",e.uid,r]),p=(()=>{var h;return t.pollingInterval?t.pollingInterval:(h=e.chain)!=null&&h.experimental_preconfirmationTime?e.chain.experimental_preconfirmationTime:e.pollingInterval})();let d,n,f,m=!1,y,P;const{promise:b,resolve:g,reject:F}=Te(),H=u?setTimeout(()=>{P==null||P(),y==null||y(),F(new Ge({hash:r}))},u):void 0;return y=Re(c,{onReplaced:l,resolve:g,reject:F},async h=>{if(f=await w(e,z,"getTransactionReceipt")({hash:r}).catch(()=>{}),f&&a<=1){clearTimeout(H),h.resolve(f),y==null||y();return}P=w(e,Ne,"watchBlockNumber")({emitMissed:!0,emitOnBegin:!0,poll:!0,pollingInterval:p,async onBlockNumber(R){const I=B=>{clearTimeout(H),P==null||P(),B(),y==null||y()};let G=R;if(!m)try{if(f){if(a>1&&(!f.blockNumber||G-f.blockNumber+1n<a))return;I(()=>h.resolve(f));return}if(s&&!d&&(m=!0,await W(async()=>{d=await w(e,Ue,"getTransaction")({hash:r}),d.blockNumber&&(G=d.blockNumber)},{delay:i,retryCount:o}),m=!1),f=await w(e,z,"getTransactionReceipt")({hash:r}),a>1&&(!f.blockNumber||G-f.blockNumber+1n<a))return;I(()=>h.resolve(f))}catch(B){if(B instanceof Z||B instanceof ee){if(!d){m=!1;return}try{n=d,m=!0;const N=await W(()=>w(e,q,"getBlock")({blockNumber:G,includeTransactions:!0}),{delay:i,retryCount:o,shouldRetry:({error:k})=>k instanceof ae});m=!1;const x=N.transactions.find(({from:k,nonce:C})=>k===n.from&&C===n.nonce);if(!x||(f=await w(e,z,"getTransactionReceipt")({hash:x.hash}),a>1&&(!f.blockNumber||G-f.blockNumber+1n<a)))return;let M="replaced";x.to===n.to&&x.value===n.value&&x.input===n.input?M="repriced":x.from===x.to&&x.value===0n&&(M="cancelled"),I(()=>{var k;(k=h.onReplaced)==null||k.call(h,{reason:M,replacedTransaction:n,transaction:x,transactionReceipt:f}),h.resolve(f)})}catch(N){I(()=>h.reject(N))}}else I(()=>h.reject(B))}}})}),b}class Ze extends v{constructor({docsPath:t}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:t,docsSlug:"account",name:"AccountNotFoundError"})}}class et extends v{constructor({docsPath:t,metaMessages:s,type:a}){super(`Account type "${a}" is not supported.`,{docsPath:t,metaMessages:s,name:"AccountTypeNotSupportedError"})}}async function tt(e,{serializedTransaction:t}){return e.request({method:"eth_sendRawTransaction",params:[t]},{retryCount:0})}export{Ze as A,et as a,Ue as b,He as c,Oe as d,De as e,q as f,Ve as g,Le as h,z as i,Je as j,re as k,Qe as l,Ke as p,Ce as r,tt as s,Ye as w};
